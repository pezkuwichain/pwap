<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about how to create custom RPC endpoints and runtime APIs."><title>pezkuwi_sdk_docs::reference_docs::custom_runtime_api_rpc - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="pezkuwi_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://pezkuwichain.io/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module custom_runtime_api_rpc</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../pezkuwi_sdk_docs/index.html">pezkuwi_<wbr>sdk_<wbr>docs</a><span class="version">0.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module custom_<wbr>runtime_<wbr>api_<wbr>rpc</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#custom-rpc-dos-and-donts" title="Custom RPC do’s and don’ts">Custom RPC do’s and don’ts</a><ul><li><a href="#background" title="Background">Background</a></li><li><a href="#problems-with-custom-rpc" title="Problems with Custom RPC">Problems with Custom RPC</a></li><li><a href="#alternatives" title="Alternatives">Alternatives</a></li><li><a href="#create-a-new-runtime-api" title="Create a new Runtime API">Create a new Runtime API</a></li><li><a href="#create-a-new-custom-rpc-legacy" title="Create a new custom RPC (Legacy)">Create a new custom RPC (Legacy)</a></li><li><a href="#add-a-new-rpc-to-the-node-legacy" title="Add a new RPC to the node (Legacy)">Add a new RPC to the node (Legacy)</a></li><li><a href="#future" title="Future">Future</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In pezkuwi_<wbr>sdk_<wbr>docs::<wbr>reference_<wbr>docs</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">pezkuwi_sdk_docs</a>::<wbr><a href="../index.html">reference_docs</a></div><h1>Module <span>custom_<wbr>runtime_<wbr>api_<wbr>rpc</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/pezkuwi_sdk_docs/reference_docs/custom_runtime_api_rpc.rs.html#1-77">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about how to create custom RPC endpoints and runtime APIs.</p>
<h2 id="custom-rpc-dos-and-donts"><a class="doc-anchor" href="#custom-rpc-dos-and-donts">§</a>Custom RPC do’s and don’ts</h2>
<p><strong>TLDR:</strong> Don’t create new custom RPCs. Instead, rely on custom Runtime APIs, combined with
<code>state_call</code>.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3>
<p>Pezkuwi-SDK offers the ability to query and subscribe storages directly. However what it does
not have is <a href="https://github.com/pezkuwichain/pezkuwi-sdk/issues/101">view functions</a>. This is an
essential feature to avoid duplicated logic between runtime and the client SDK. Custom RPC was
used as a solution. It allow the RPC node to expose new RPCs that clients can be used to query
computed properties.</p>
<h3 id="problems-with-custom-rpc"><a class="doc-anchor" href="#problems-with-custom-rpc">§</a>Problems with Custom RPC</h3>
<p>Unfortunately, custom RPC comes with many problems. To list a few:</p>
<ul>
<li>It is offchain logic executed by the RPC node and therefore the client has to trust the RPC
node.</li>
<li>To upgrade or add a new RPC logic, the RPC node has to be upgraded. This can cause significant
trouble when the RPC infrastructure is decentralized as we will need to coordinate multiple
parties to upgrade the RPC nodes.</li>
<li>A lot of boilerplate code is required to add custom RPC.</li>
<li>It prevents dApps from using a light client or an alternative client.</li>
<li>It makes ecosystem tooling integration much more complicated. For example, dApps will not
be able to use <a href="https://github.com/AcalaNetwork/chopsticks">Chopsticks</a> for testing as
Chopsticks will not have the custom RPC implementation.</li>
<li>Poorly implemented custom RPC can be a DoS vector.</li>
</ul>
<p>Hence, we should avoid custom RPC.</p>
<h3 id="alternatives"><a class="doc-anchor" href="#alternatives">§</a>Alternatives</h3>
<p>Generally, [<code>sc_rpc::state::StateBackend::call</code>] aka. <code>state_call</code> should be used instead of
custom RPC.</p>
<p>Usually, each custom RPC comes with a corresponding runtime API which implements the business
logic. So instead of invoke the custom RPC, we can use <code>state_call</code> to invoke the runtime API
directly. This is a trivial change on the dApp and no change on the runtime side. We may remove
the custom RPC from the node side if wanted.</p>
<p>There are some other cases that a simple runtime API is not enough. For example, implementation
of Ethereum RPC requires an additional offchain database to index transactions. In this
particular case, we can have the RPC implemented on another client.</p>
<p>For example, the Acala EVM+ RPC are implemented by
<a href="https://github.com/AcalaNetwork/bodhi.js/tree/master/packages/eth-rpc-adapter">eth-rpc-adapter</a>.
Alternatively, the <a href="https://github.com/pezkuwi-evm/frontier">Frontier</a> project  also provided
Ethereum RPC compatibility directly in the node-side software.</p>
<h3 id="create-a-new-runtime-api"><a class="doc-anchor" href="#create-a-new-runtime-api">§</a>Create a new Runtime API</h3>
<p>For example, let’s take a look at the process through which the account nonce can be queried
through an RPC. First, a new runtime-api needs to be declared:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">sp_api::decl_runtime_apis!</span> {
	<span class="doccomment">/// The API to query account nonce.
	</span><span class="kw">pub trait </span>AccountNonceApi&lt;AccountId, Nonce&gt; <span class="kw">where
		</span>AccountId: codec::Codec,
		Nonce: codec::Codec,
	{
		<span class="doccomment">/// Get current account nonce of given `AccountId`.
		</span><span class="kw">fn </span>account_nonce(account: AccountId) -&gt; Nonce;
	}
}</code></pre></div>
<p>This API is implemented at the runtime level, always inside [<code>sp_api::impl_runtime_apis!</code>].</p>
<p>As noted, this is already enough to make this API usable via <code>state_call</code>.</p>
<h3 id="create-a-new-custom-rpc-legacy"><a class="doc-anchor" href="#create-a-new-custom-rpc-legacy">§</a>Create a new custom RPC (Legacy)</h3>
<p>Should you wish to implement the legacy approach of exposing this runtime-api as a custom
RPC-api, then a custom RPC server has to be defined.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[rpc(client, server)]
</span><span class="kw">pub trait </span>SystemApi&lt;BlockHash, AccountId, Nonce&gt; {
	<span class="doccomment">/// Returns the next valid index (aka nonce) for given account.
	///
	/// This method takes into consideration all pending transactions
	/// currently in the pool and if no transactions are found in the pool
	/// it fallbacks to query the index from the runtime (aka. state nonce).
	</span><span class="attr">#[method(name = <span class="string">"system_accountNextIndex"</span>, aliases = [<span class="string">"account_nextIndex"</span>]</span>)]
	<span class="kw">async fn </span>nonce(<span class="kw-2">&amp;</span><span class="self">self</span>, account: AccountId) -&gt; RpcResult&lt;Nonce&gt;;

	<span class="doccomment">/// Dry run an extrinsic at a given block. Return SCALE encoded ApplyExtrinsicResult.
	</span><span class="attr">#[method(name = <span class="string">"system_dryRun"</span>, aliases = [<span class="string">"system_dryRunAt"</span>]</span>, with_extensions)]
	<span class="kw">async fn </span>dry_run(<span class="kw-2">&amp;</span><span class="self">self</span>, extrinsic: Bytes, at: <span class="prelude-ty">Option</span>&lt;BlockHash&gt;) -&gt; RpcResult&lt;Bytes&gt;;
}</code></pre></div><h3 id="add-a-new-rpc-to-the-node-legacy"><a class="doc-anchor" href="#add-a-new-rpc-to-the-node-legacy">§</a>Add a new RPC to the node (Legacy)</h3>
<p>Finally, this custom RPC needs to be integrated into the node side. This is usually done in a
<code>rpc.rs</code> in a typical template, as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>create_full&lt;C, P&gt;(
	deps: FullDeps&lt;C, P&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;RpcModule&lt;()&gt;, Box&lt;<span class="kw">dyn </span>std::error::Error + Send + Sync&gt;&gt;
<span class="kw">where
	</span>C: Send
		+ Sync
		+ <span class="lifetime">'static
		</span>+ sp_api::ProvideRuntimeApi&lt;OpaqueBlock&gt;
		+ HeaderBackend&lt;OpaqueBlock&gt;
		+ HeaderMetadata&lt;OpaqueBlock, Error = BlockChainError&gt;
		+ <span class="lifetime">'static</span>,
	C::Api: sp_block_builder::BlockBuilder&lt;OpaqueBlock&gt;,
	C::Api: substrate_frame_rpc_system::AccountNonceApi&lt;OpaqueBlock, AccountId, Nonce&gt;,
	P: TransactionPool + <span class="lifetime">'static</span>,
{
	<span class="kw">use </span>pezkuwi_sdk::substrate_frame_rpc_system::{System, SystemApiServer};
	<span class="kw">let </span><span class="kw-2">mut </span>module = RpcModule::new(());
	<span class="kw">let </span>FullDeps { client, pool } = deps;

	module.merge(System::new(client.clone(), pool.clone()).into_rpc())<span class="question-mark">?</span>;

	<span class="prelude-val">Ok</span>(module)
}</code></pre></div><h3 id="future"><a class="doc-anchor" href="#future">§</a>Future</h3>
<ul>
<li><a href="https://forum.network.pezkuwichain.io/t/cross-consensus-query-language-xcq/7583">XCQ</a> will be a good
solution for most of the query needs.</li>
<li><a href="https://github.com/paritytech/json-rpc-interface-spec">New JSON-RPC Specification</a></li>
</ul>
</div></details></section></div></main></body></html>