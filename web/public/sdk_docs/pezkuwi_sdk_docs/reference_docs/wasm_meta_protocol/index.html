<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about the WASM meta-protocol of all Substrate-based chains."><title>pezkuwi_sdk_docs::reference_docs::wasm_meta_protocol - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="pezkuwi_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://pezkuwichain.io/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module wasm_meta_protocol</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../pezkuwi_sdk_docs/index.html">pezkuwi_<wbr>sdk_<wbr>docs</a><span class="version">0.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module wasm_<wbr>meta_<wbr>protocol</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#wasm-meta-protocol" title="WASM Meta Protocol">WASM Meta Protocol</a><ul><li><a href="#node-vs-runtime" title="Node vs. Runtime">Node vs. Runtime</a></li><li><a href="#state" title="State">State</a></li><li><a href="#native-runtime" title="Native Runtime">Native Runtime</a></li><li><a href="#example-block-execution" title="Example: Block Execution.">Example: Block Execution.</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In pezkuwi_<wbr>sdk_<wbr>docs::<wbr>reference_<wbr>docs</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">pezkuwi_sdk_docs</a>::<wbr><a href="../index.html">reference_docs</a></div><h1>Module <span>wasm_<wbr>meta_<wbr>protocol</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/pezkuwi_sdk_docs/reference_docs/wasm_meta_protocol.rs.html#1-158">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about the WASM meta-protocol of all Substrate-based chains.</p>
<h2 id="wasm-meta-protocol"><a class="doc-anchor" href="#wasm-meta-protocol">¬ß</a>WASM Meta Protocol</h2>
<p>All Substrate based chains adhere to a unique architectural design novel to the Pezkuwi
ecosystem. We refer to this design as the ‚Äú<strong>WASM Meta Protocol</strong>‚Äù.</p>
<p>Consider the fact that a traditional blockchain software is usually a monolithic artifact.
<strong>Upgrading any part of the system implies upgrading the entire system</strong>. This has historically
led to cumbersome forkful upgrades to be the status quo in blockchain ecosystems. In other
words, the entire node software is the specification of the blockchain‚Äôs <a href="../blockchain_state_machines/index.html" title="mod pezkuwi_sdk_docs::reference_docs::blockchain_state_machines"><code>state transition function</code></a>.</p>
<p>Moreover, the idea of ‚Äústoring code in the state‚Äù is explored in the context of smart contracts
platforms, but has not been expanded further.</p>
<p>Substrate mixes these two ideas together, and takes the novel approach of storing the
blockchain‚Äôs main ‚Äústate transition function‚Äù in the main blockchain state, in the same fashion
that a smart contract platform stores the code of individual contracts in its state. As noted in
<a href="../blockchain_state_machines/index.html" title="mod pezkuwi_sdk_docs::reference_docs::blockchain_state_machines"><code>crate::reference_docs::blockchain_state_machines</code></a>, this state transition function is called
the <strong>Runtime</strong>, and WASM is chosen as the bytecode. The Runtime is stored under a special key
in the state (see [<code>sp_core::storage::well_known_keys</code>]) and can be updated as a part of the
state transition function‚Äôs execution, just like a user‚Äôs account balance can be updated.</p>
<blockquote>
<p>Note that while we drew an analogy between smart contracts and runtimes in the above, there
are fundamental differences between the two, explained in
<a href="../runtime_vs_smart_contract/index.html" title="mod pezkuwi_sdk_docs::reference_docs::runtime_vs_smart_contract"><code>crate::reference_docs::runtime_vs_smart_contract</code></a>.</p>
</blockquote>
<p>The rest of the system that is NOT the state transition function is called the
<a href="../glossary/index.html#node" title="mod pezkuwi_sdk_docs::reference_docs::glossary"><strong>Node</strong></a>, and is a normal binary that is compiled from
Rust to different hardware targets.</p>
<p>This design enables all Substrate-based chains to be fork-less-ly upgradeable, because the
Runtime can be updated on the fly, within the execution of a block, and the node is (for the
most part) oblivious to the change that is happening.</p>
<p>Therefore, the high-level architecture of a any Substrate-based chain can be demonstrated as
follows:</p>
<pre class="mermaid" style="text-align:center;background: transparent;">
graph TB
subgraph Substrate
	direction LR
	subgraph Node
	end
	subgraph Runtime
	end
end

</pre><script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false,
    theme: 'dark',
    flowchart: { useMaxWidth: true, htmlLabels: true },
    suppressErrorRendering: true
});
document.addEventListener('DOMContentLoaded', async () => {
    const elements = document.querySelectorAll('.mermaid');
    for (const el of elements) {
        const code = el.textContent;
        try {
            const { svg } = await mermaid.render('mermaid-' + Math.random().toString(36).substr(2, 9), code);
            el.innerHTML = svg;
        } catch (e) {
            // On error, show as styled code block
            el.style.fontFamily = 'monospace';
            el.style.whiteSpace = 'pre';
            el.style.background = '#1e293b';
            el.style.padding = '1rem';
            el.style.borderRadius = '8px';
            el.style.color = '#94a3b8';
            el.style.fontSize = '0.85rem';
            el.style.border = '1px solid #334155';
        }
    }
});
</script>
<p>The node and the runtime need to communicate. This is done through two concepts:</p>
<ol>
<li><strong>Host functions</strong>: a way for the (WASM) runtime to talk to the node. All host functions are
defined in [<code>sp_io</code>]. For example, [<code>sp_io::storage</code>] are the set of host functions that
allow the runtime to read and write data to the on-chain state.</li>
<li><strong>Runtime APIs</strong>: a way for the node to talk to the WASM runtime. Runtime APIs are defined
using macros and utilities in [<code>sp_api</code>]. For example, [<code>sp_api::Core</code>] is the most
fundamental runtime API that any blockchain must implement in order to be able to (re)
execute blocks.</li>
</ol>
<pre class="mermaid" style="text-align:center;background: transparent;">
graph TB
subgraph Substrate
	direction LR
	subgraph Node
	end

	subgraph Runtime
	end

	Node --runtime-api--> Runtime
	Runtime --host-functions--> Node
end

</pre><script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false,
    theme: 'dark',
    flowchart: { useMaxWidth: true, htmlLabels: true },
    suppressErrorRendering: true
});
document.addEventListener('DOMContentLoaded', async () => {
    const elements = document.querySelectorAll('.mermaid');
    for (const el of elements) {
        const code = el.textContent;
        try {
            const { svg } = await mermaid.render('mermaid-' + Math.random().toString(36).substr(2, 9), code);
            el.innerHTML = svg;
        } catch (e) {
            // On error, show as styled code block
            el.style.fontFamily = 'monospace';
            el.style.whiteSpace = 'pre';
            el.style.background = '#1e293b';
            el.style.padding = '1rem';
            el.style.borderRadius = '8px';
            el.style.color = '#94a3b8';
            el.style.fontSize = '0.85rem';
            el.style.border = '1px solid #334155';
        }
    }
});
</script>
<p>A runtime must have a set of runtime APIs in order to have any meaningful blockchain
functionality, but it can also expose more APIs. See
<a href="../custom_runtime_api_rpc/index.html" title="mod pezkuwi_sdk_docs::reference_docs::custom_runtime_api_rpc"><code>crate::reference_docs::custom_runtime_api_rpc</code></a> as an example of how to add custom runtime
APIs to your FRAME-based runtime.</p>
<p>Similarly, for a runtime to be ‚Äúcompatible‚Äù with a node, the node must implement the full set of
host functions that the runtime at any point in time requires. Given the fact that a runtime can
evolve in time, and a blockchain node (typically) wishes to be capable of re-executing all the
previous blocks, this means that a node must always maintain support for the old host functions.
<strong>This implies that adding a new host function is a big commitment and should be done with
care</strong>. This is why, for example, adding a new host function to Pezkuwi always requires an RFC.
Learn how to add a new host function to your runtime in
<a href="../custom_host_functions/index.html" title="mod pezkuwi_sdk_docs::reference_docs::custom_host_functions"><code>crate::reference_docs::custom_host_functions</code></a>.</p>
<h3 id="node-vs-runtime"><a class="doc-anchor" href="#node-vs-runtime">¬ß</a>Node vs. Runtime</h3>
<p>A common question is: which components of the system end up being part of the node, and which
ones of the runtime?</p>
<p>Recall from <a href="../blockchain_state_machines/index.html" title="mod pezkuwi_sdk_docs::reference_docs::blockchain_state_machines"><code>crate::reference_docs::blockchain_state_machines</code></a> that the runtime is the state
transition function. Anything that needs to influence how your blockchain‚Äôs state is updated,
should be a part of the runtime. For example, the logic around currency, governance, identity or
any other application-specific logic that has to do with the state is part of the runtime.</p>
<p>Anything that does not have to do with the state-transition function and will only
facilitate/enable it is part of the node. For example, the database, networking, and even
consensus algorithm are all node-side components.</p>
<blockquote>
<p>The consensus is to your runtime what HTTP is to a web-application. It is the underlying
engine that enables trustless execution of the runtime in a distributed manner whilst
maintaining a canonical outcome of that execution.</p>
</blockquote>
<pre class="mermaid" style="text-align:center;background: transparent;">
graph TB
subgraph Substrate
	direction LR
	subgraph Node
		Database
		Networking
		Consensus
	end
	subgraph Runtime
		subgraph FRAME
			direction LR
			Governance
			Currency
			Staking
			Identity
		end
	end
	Node --runtime-api--> Runtime
	Runtime --host-functions--> Node
end

</pre><script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false,
    theme: 'dark',
    flowchart: { useMaxWidth: true, htmlLabels: true },
    suppressErrorRendering: true
});
document.addEventListener('DOMContentLoaded', async () => {
    const elements = document.querySelectorAll('.mermaid');
    for (const el of elements) {
        const code = el.textContent;
        try {
            const { svg } = await mermaid.render('mermaid-' + Math.random().toString(36).substr(2, 9), code);
            el.innerHTML = svg;
        } catch (e) {
            // On error, show as styled code block
            el.style.fontFamily = 'monospace';
            el.style.whiteSpace = 'pre';
            el.style.background = '#1e293b';
            el.style.padding = '1rem';
            el.style.borderRadius = '8px';
            el.style.color = '#94a3b8';
            el.style.fontSize = '0.85rem';
            el.style.border = '1px solid #334155';
        }
    }
});
</script>
<h3 id="state"><a class="doc-anchor" href="#state">¬ß</a>State</h3>
<p>From the previous sections, we know that the database component is part of the node, not the
runtime. We also hinted that a set of host functions ([<code>sp_io::storage</code>]) are how the runtime
issues commands to the node to read/write to the state. Let‚Äôs dive deeper into this.</p>
<p>The state of the blockchain, what we seek to come to consensus about, is indeed <em>kept</em> in the
node side. Nonetheless, the runtime is the only component that:</p>
<ol>
<li>Can update the state.</li>
<li>Can fully interpret the state.</li>
</ol>
<p>In fact, [<code>sp_core::storage::well_known_keys</code>] are the only state keys that the node side is
aware of. The rest of the state, including what logic the runtime has, what balance each user
has and such, are all only comprehensible to the runtime.</p>
<pre class="mermaid" style="text-align:center;background: transparent;">
flowchart TB
    subgraph Node[Node's View Of The State üôà]
        direction LR
        0x1234 --> 0x2345
        0x3456 --> 0x4567
        0x5678 --> 0x6789
        :code --> code[wasm code]
    end

    subgraph Runtime[Runtime's View Of The State üôâ]
        direction LR
        ab[alice's balance] --> abv[known value]
        bb[bob's balance] --> bbv[known value]
        cb[charlie's balance] --> cbv[known value]
        c2[:code] --> c22[wasm code]
    end

</pre><script src="https://cdn.jsdelivr.net/npm/mermaid@9.4.3/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: false,
    theme: 'dark',
    flowchart: { useMaxWidth: true, htmlLabels: true },
    suppressErrorRendering: true
});
document.addEventListener('DOMContentLoaded', async () => {
    const elements = document.querySelectorAll('.mermaid');
    for (const el of elements) {
        const code = el.textContent;
        try {
            const { svg } = await mermaid.render('mermaid-' + Math.random().toString(36).substr(2, 9), code);
            el.innerHTML = svg;
        } catch (e) {
            // On error, show as styled code block
            el.style.fontFamily = 'monospace';
            el.style.whiteSpace = 'pre';
            el.style.background = '#1e293b';
            el.style.padding = '1rem';
            el.style.borderRadius = '8px';
            el.style.color = '#94a3b8';
            el.style.fontSize = '0.85rem';
            el.style.border = '1px solid #334155';
        }
    }
});
</script>
<p>In the above diagram, all of the state keys and values are opaque bytes to the node. The node
does not know what they mean, and it does not know what is the type of the corresponding value
(e.g. if it is a number of a vector). Contrary, the runtime knows both the meaning of their
keys, and the type of the values.</p>
<p>This opaque-ness is the fundamental reason why Substrate-based chains can fork-less-ly upgrade:
because the node side code is kept oblivious to all of the details of the state transition
function. Therefore, the state transition function can freely upgrade without the node needing
to know.</p>
<h3 id="native-runtime"><a class="doc-anchor" href="#native-runtime">¬ß</a>Native Runtime</h3>
<p>Historically, the node software also kept a native copy of the runtime at the time of
compilation within it. This used to be called the ‚ÄúNative Runtime‚Äù. The main purpose of the
native runtime used to be leveraging the faster execution time and better debugging
infrastructure of native code. However, neither of the two arguments strongly hold and the
native runtime is being fully removed from the node-sdk.</p>
<p>See: <a href="https://github.com/pezkuwichain/pezkuwi-sdk/issues/97">https://github.com/pezkuwichain/pezkuwi-sdk/issues/97</a></p>
<blockquote>
<p>Also, note that the flags [<code>sc_cli::ExecutionStrategy::Native</code>] is already a noop and all
chains built with Substrate only use WASM execution.</p>
</blockquote>
<h4 id="runtime-versions"><a class="doc-anchor" href="#runtime-versions">¬ß</a>Runtime Versions</h4>
<p>An important detail of the native execution worth learning about is that the node software,
obviously, only uses the native runtime if it is the same code as with the wasm blob stored
onchain. Else, nodes who run the native runtime will come to a different state transition. How
do nodes determine if two runtimes are the same? Through the very important
[<code>sp_version::RuntimeVersion</code>]. All runtimes expose their version via a runtime api
([<code>sp_api::Core::version</code>]) that returns this struct. The node software, or other applications,
inspect this struct to examine the identity of a runtime, and to determine if two runtimes are
the same. Namely, [<code>sp_version::RuntimeVersion::spec_version</code>] is the main key that implies two
runtimes are the same.</p>
<p>Therefore, it is utmost important to make sure before any runtime upgrade, the spec version is
updated.</p>
<h3 id="example-block-execution"><a class="doc-anchor" href="#example-block-execution">¬ß</a>Example: Block Execution.</h3>
<p>As a final example to recap, let‚Äôs look at how Substrate-based nodes execute blocks. Blocks are
received in the node side software as opaque blobs and in the networking layer.</p>
<p>At some point, based on the consensus algorithm‚Äôs rules, the node decides to import (aka.
<em>validate</em>) a block.</p>
<ul>
<li>First, the node will fetch the state of the parent hash of the block that wishes to be
imported.</li>
<li>The runtime is fetched from this state, and placed into a WASM execution environment.</li>
<li>The [<code>sp_api::Core::execute_block</code>] runtime API is called and the block is passed in as an
argument.</li>
<li>The runtime will then execute the block, and update the state accordingly. Any state update is
issued via the [<code>sp_io::storage</code>] host functions.</li>
<li>Both the runtime and node will check the state-root of the state after the block execution to
match the one claimed in the block header.</li>
</ul>
<blockquote>
<p>Example taken from <a href="https://www.youtube.com/watch?v=v0cKuddbF_Q&amp;list=PL-w_i5kwVqbkRmfDn5nzeuU1S_FFW8dDg&amp;index=4">this
lecture</a>
of the Pezkuwi Blockchain Academy.</p>
</blockquote>
</div></details></section></div></main></body></html>