<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="How to enable Async Backing on teyrchain projects that started in 2023 or before."><title>pezkuwi_sdk_docs::guides::async_backing_guide - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="pezkuwi_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.1 (ed61e7d7e 2025-11-07)" data-channel="1.91.1" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://pezkuwichain.io/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module async_backing_guide</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../pezkuwi_sdk_docs/index.html">pezkuwi_<wbr>sdk_<wbr>docs</a><span class="version">0.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module async_<wbr>backing_<wbr>guide</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#upgrade-teyrchain-for-asynchronous-backing-compatibility" title="Upgrade Teyrchain for Asynchronous Backing Compatibility">Upgrade Teyrchain for Asynchronous Backing Compatibility</a><ul><li><a href="#prerequisite" title="Prerequisite">Prerequisite</a></li><li><a href="#phase-1---update-teyrchain-runtime" title="Phase 1 - Update Teyrchain Runtime">Phase 1 - Update Teyrchain Runtime</a></li><li><a href="#phase-2---update-teyrchain-nodes" title="Phase 2 - Update Teyrchain Nodes">Phase 2 - Update Teyrchain Nodes</a></li><li><a href="#phase-3---activate-async-backing" title="Phase 3 - Activate Async Backing">Phase 3 - Activate Async Backing</a></li><li><a href="#timing-by-block-number" title="Timing by Block Number">Timing by Block Number</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In pezkuwi_<wbr>sdk_<wbr>docs::<wbr>guides</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">pezkuwi_sdk_docs</a>::<wbr><a href="../index.html">guides</a></div><h1>Module <span>async_<wbr>backing_<wbr>guide</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/pezkuwi_sdk_docs/guides/async_backing_guide.rs.html#1-254">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>How to enable Async Backing on teyrchain projects that started in 2023 or before.</p>
<h2 id="upgrade-teyrchain-for-asynchronous-backing-compatibility"><a class="doc-anchor" href="#upgrade-teyrchain-for-asynchronous-backing-compatibility">§</a>Upgrade Teyrchain for Asynchronous Backing Compatibility</h2>
<p>This guide is relevant for cumulus based teyrchain projects started in 2023 or before, whose
backing process is synchronous where parablocks can only be built on the latest Relay Chain
block. Async Backing allows collators to build parablocks on older Relay Chain blocks and create
pipelines of multiple pending parablocks. This parallel block generation increases efficiency
and throughput. For more information on Async backing and its terminology, refer to the document
on <a href="https://docs.pezkuwichain.io/sdk/master/pezkuwi_sdk_docs/guides/async_backing_guide/index.html">the Pezkuwi SDK docs.</a></p>
<blockquote>
<p>If starting a new teyrchain project, please use an async backing compatible template such as
the
<a href="https://github.com/pezkuwichain/pezkuwi-sdk/tree/master/templates/teyrchain">teyrchain template</a>.
The rollout process for Async Backing has three phases. Phases 1 and 2 below put new
infrastructure in place. Then we can simply turn on async backing in phase 3.</p>
</blockquote>
<h3 id="prerequisite"><a class="doc-anchor" href="#prerequisite">§</a>Prerequisite</h3>
<p>The relay chain needs to have async backing enabled so double-check that the relay-chain
configuration contains the following three parameters (especially when testing locally e.g. with
zombienet):</p>
<div class="example-wrap"><pre class="language-json"><code>&quot;async_backing_params&quot;: {
    &quot;max_candidate_depth&quot;: 3,
    &quot;allowed_ancestry_len&quot;: 2
},
&quot;scheduling_lookahead&quot;: 2</code></pre></div><div class="warning"><code>scheduling_lookahead</code> must be set to 2, otherwise teyrchain
block times will degrade to worse than with sync backing!</div>
<h3 id="phase-1---update-teyrchain-runtime"><a class="doc-anchor" href="#phase-1---update-teyrchain-runtime">§</a>Phase 1 - Update Teyrchain Runtime</h3>
<p>This phase involves configuring your teyrchain’s runtime <code>/runtime/src/lib.rs</code> to make use of
async backing system.</p>
<ol>
<li>Establish and ensure constants for <code>capacity</code> and <code>velocity</code> are both set to 1 in the
runtime.</li>
<li>Establish and ensure the constant relay chain slot duration measured in milliseconds equal to
<code>6000</code> in the runtime.</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Maximum number of blocks simultaneously accepted by the Runtime, not yet included into the
// relay chain.
</span><span class="kw">pub const </span>UNINCLUDED_SEGMENT_CAPACITY: u32 = <span class="number">1</span>;
<span class="comment">// How many teyrchain blocks are processed by the relay chain per parent. Limits the number of
// blocks authored per slot.
</span><span class="kw">pub const </span>BLOCK_PROCESSING_VELOCITY: u32 = <span class="number">1</span>;
<span class="comment">// Relay chain slot duration, in milliseconds.
</span><span class="kw">pub const </span>RELAY_CHAIN_SLOT_DURATION_MILLIS: u32 = <span class="number">6000</span>;</code></pre></div>
<ol start="3">
<li>Establish constants <code>MILLISECS_PER_BLOCK</code> and <code>SLOT_DURATION</code> if not already present in the
runtime.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked
// up by `pallet_aura` to implement `fn slot_duration()`.
//
// Change this to adjust the block time.
</span><span class="kw">pub const </span>MILLISECS_PER_BLOCK: u64 = <span class="number">12000</span>;
<span class="kw">pub const </span>SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;</code></pre></div>
<ol start="4">
<li>Configure <code>cumulus_pallet_teyrchain_system</code> in the runtime.</li>
</ol>
<ul>
<li>Define a <code>FixedVelocityConsensusHook</code> using our capacity, velocity, and relay slot duration
constants. Use this to set the teyrchain system <code>ConsensusHook</code> property.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">type </span>ConsensusHook = cumulus_pallet_aura_ext::FixedVelocityConsensusHook&lt;
	Runtime,
	RELAY_CHAIN_SLOT_DURATION_MILLIS,
	BLOCK_PROCESSING_VELOCITY,
	UNINCLUDED_SEGMENT_CAPACITY,
&gt;;</code></pre></div>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>cumulus_pallet_teyrchain_system::Config <span class="kw">for </span>Runtime {
    ..
    <span class="kw">type </span>ConsensusHook = ConsensusHook;
    ..
}</code></pre></div>
<ul>
<li>Set the teyrchain system property <code>CheckAssociatedRelayNumber</code> to
<code>RelayNumberMonotonicallyIncreases</code></li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>cumulus_pallet_teyrchain_system::Config <span class="kw">for </span>Runtime {
	..
	<span class="kw">type </span>CheckAssociatedRelayNumber = RelayNumberMonotonicallyIncreases;
	..
}</code></pre></div>
<ol start="5">
<li>Configure <code>pallet_aura</code> in the runtime.</li>
</ol>
<ul>
<li>
<p>Set <code>AllowMultipleBlocksPerSlot</code> to <code>false</code> (don’t worry, we will set it to <code>true</code> when we
activate async backing in phase 3).</p>
</li>
<li>
<p>Define <code>pallet_aura::SlotDuration</code> using our constant <code>SLOT_DURATION</code></p>
</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>pallet_aura::Config <span class="kw">for </span>Runtime {
	..
	<span class="kw">type </span>AllowMultipleBlocksPerSlot = ConstBool&lt;<span class="bool-val">false</span>&gt;;
	<span class="attr">#[cfg(feature = <span class="string">"experimental"</span>)]
	</span><span class="kw">type </span>SlotDuration = ConstU64&lt;SLOT_DURATION&gt;;
	..
}</code></pre></div>
<ol start="6">
<li>Update <code>sp_consensus_aura::AuraApi::slot_duration</code> in <code>sp_api::impl_runtime_apis</code> to match
the constant <code>SLOT_DURATION</code></li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>impl_slot_duration() -&gt; sp_consensus_aura::SlotDuration {
	sp_consensus_aura::SlotDuration::from_millis(SLOT_DURATION)
}</code></pre></div>
<ol start="7">
<li>
<p>Implement the <code>AuraUnincludedSegmentApi</code>, which allows the collator client to query its
runtime to determine whether it should author a block.</p>
<ul>
<li>Add the dependency <code>cumulus-primitives-aura</code> to the <code>runtime/Cargo.toml</code> file for your
runtime</li>
</ul>
</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>..
cumulus-primitives-aura = { path = <span class="string">"../../../../primitives/aura"</span>, default-features = <span class="bool-val">false </span>}
..</code></pre></div>
<ul>
<li>
<p>In the same file, add <code>"cumulus-primitives-aura/std",</code> to the <code>std</code> feature.</p>
</li>
<li>
<p>Inside the <code>impl_runtime_apis!</code> block for your runtime, implement the
<code>cumulus_primitives_aura::AuraUnincludedSegmentApi</code> as shown below.</p>
</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>impl_can_build_upon(
	included_hash: &lt;Block <span class="kw">as </span>BlockT&gt;::Hash,
	slot: cumulus_primitives_aura::Slot,
) -&gt; bool {
	ConsensusHook::can_build_upon(included_hash, slot)
}</code></pre></div>
<p><strong>Note:</strong> With a capacity of 1 we have an effective velocity of ½ even when velocity is
configured to some larger value. This is because capacity will be filled after a single block is
produced and will only be freed up after that block is included on the relay chain, which takes
2 relay blocks to accomplish. Thus with capacity 1 and velocity 1 we get the customary 12 second
teyrchain block time.</p>
<ol start="8">
<li>If your <code>runtime/src/lib.rs</code> provides a <code>CheckInherents</code> type to <code>register_validate_block</code>,
remove it. <code>FixedVelocityConsensusHook</code> makes it unnecessary. The following example shows how
<code>register_validate_block</code> should look after removing <code>CheckInherents</code>.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">cumulus_pallet_teyrchain_system::register_validate_block!</span> {
	Runtime = Runtime,
	BlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::&lt;Runtime, Executive&gt;,
}</code></pre></div><h3 id="phase-2---update-teyrchain-nodes"><a class="doc-anchor" href="#phase-2---update-teyrchain-nodes">§</a>Phase 2 - Update Teyrchain Nodes</h3>
<p>This phase consists of plugging in the new lookahead collator node.</p>
<ol>
<li>Import <code>cumulus_primitives_core::ValidationCode</code> to <code>node/src/service.rs</code>.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cumulus_primitives_core::{
	relay_chain::{CollatorPair, ValidationCode},
	GetTeyrchainInfo, ParaId,
};</code></pre></div>
<ol start="2">
<li>In <code>node/src/service.rs</code>, modify <code>sc_service::spawn_tasks</code> to use a clone of <code>Backend</code> rather
than the original</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>sc_service::spawn_tasks(sc_service::SpawnTasksParams {
    ..
    backend: backend.clone(),
    ..
})<span class="question-mark">?</span>;</code></pre></div>
<ol start="3">
<li>Add <code>backend</code> as a parameter to <code>start_consensus()</code> in <code>node/src/service.rs</code></li>
</ol>
<div class="example-wrap"><pre class="language-text"><code>fn start_consensus(
    ..
    backend: Arc&lt;TeyrchainBackend&gt;,
    ..</code></pre></div>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">if </span>validator {
  start_consensus(
    ..
    backend.clone(),
    ..
   )<span class="question-mark">?</span>;
}</code></pre></div>
<ol start="4">
<li>In <code>node/src/service.rs</code> import the lookahead collator rather than the basic collator</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cumulus_client_consensus_aura::collators::lookahead::{<span class="self">self </span><span class="kw">as </span>aura, Params <span class="kw">as </span>AuraParams};</code></pre></div>
<ol start="5">
<li>In <code>start_consensus()</code> replace the <code>BasicAuraParams</code> struct with <code>AuraParams</code>
<ul>
<li>Change the struct type from <code>BasicAuraParams</code> to <code>AuraParams</code></li>
<li>In the <code>para_client</code> field, pass in a cloned para client rather than the original</li>
<li>Add a <code>para_backend</code> parameter after <code>para_client</code>, passing in our para backend</li>
<li>Provide a <code>code_hash_provider</code> closure like that shown below</li>
<li>Increase <code>authoring_duration</code> from 500 milliseconds to 2000</li>
</ul>
</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>params = AuraParams {
    ..
    para_client: client.clone(),
    para_backend: backend.clone(),
    ..
    code_hash_provider: <span class="kw">move </span>|block_hash| {
        client.code_at(block_hash).ok().map(|c| ValidationCode::from(c).hash())
    },
    ..
    authoring_duration: Duration::from_millis(<span class="number">2000</span>),
    ..
};</code></pre></div>
<p><strong>Note:</strong> Set <code>authoring_duration</code> to whatever you want, taking your own hardware into account.
But if the backer who should be slower than you due to reading from disk, times out at two
seconds your candidates will be rejected.</p>
<ol start="6">
<li>In <code>start_consensus()</code> replace <code>basic_aura::run</code> with <code>aura::run</code></li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fut =
aura::run::&lt;Block, sp_consensus_aura::sr25519::AuthorityPair, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>&gt;(
   params,
);
task_manager.spawn_essential_handle().spawn(<span class="string">"aura"</span>, <span class="prelude-val">None</span>, fut);</code></pre></div><h3 id="phase-3---activate-async-backing"><a class="doc-anchor" href="#phase-3---activate-async-backing">§</a>Phase 3 - Activate Async Backing</h3>
<p>This phase consists of changes to your teyrchain’s runtime that activate async backing feature.</p>
<ol>
<li>Configure <code>pallet_aura</code>, setting <code>AllowMultipleBlocksPerSlot</code> to true in
<code>runtime/src/lib.rs</code>.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>pallet_aura::Config <span class="kw">for </span>Runtime {
	<span class="kw">type </span>AuthorityId = AuraId;
	<span class="kw">type </span>DisabledValidators = ();
	<span class="kw">type </span>MaxAuthorities = ConstU32&lt;<span class="number">100_000</span>&gt;;
	<span class="kw">type </span>AllowMultipleBlocksPerSlot = ConstBool&lt;<span class="bool-val">true</span>&gt;;
	<span class="kw">type </span>SlotDuration = ConstU64&lt;SLOT_DURATION&gt;;
}</code></pre></div>
<ol start="2">
<li>Increase the maximum <code>UNINCLUDED_SEGMENT_CAPACITY</code> in <code>runtime/src/lib.rs</code>.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>async_backing_params {
	<span class="doccomment">/// Maximum number of blocks simultaneously accepted by the Runtime, not yet included
	/// into the relay chain.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>UNINCLUDED_SEGMENT_CAPACITY: u32 = <span class="number">3</span>;
	<span class="doccomment">/// How many teyrchain blocks are processed by the relay chain per parent. Limits the
	/// number of blocks authored per slot.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>BLOCK_PROCESSING_VELOCITY: u32 = <span class="number">1</span>;
	<span class="doccomment">/// Relay chain slot duration, in milliseconds.
	</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">const </span>RELAY_CHAIN_SLOT_DURATION_MILLIS: u32 = <span class="number">6000</span>;
}</code></pre></div>
<ol start="3">
<li>Decrease <code>MILLISECS_PER_BLOCK</code> to 6000.</li>
</ol>
<ul>
<li>Note: For a teyrchain which measures time in terms of its own block number rather than by
relay block number it may be preferable to increase velocity. Changing block time may cause
complications, requiring additional changes. See the section “Timing by Block Number”.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>block_times {
	<span class="doccomment">/// This determines the average expected block time that we are targeting. Blocks will be
	/// produced at a minimum duration defined by `SLOT_DURATION`. `SLOT_DURATION` is picked up by
	/// `pallet_timestamp` which is in turn picked up by `pallet_aura` to implement `fn
	/// slot_duration()`.
	///
	/// Change this to adjust the block time.
	</span><span class="kw">pub const </span>MILLI_SECS_PER_BLOCK: u64 = <span class="number">6000</span>;

	<span class="comment">// NOTE: Currently it is not possible to change the slot duration after the chain has started.
	// Attempting to do so will brick block production.
	</span><span class="kw">pub const </span>SLOT_DURATION: u64 = MILLI_SECS_PER_BLOCK;
}</code></pre></div>
<ol start="4">
<li>Update <code>MAXIMUM_BLOCK_WEIGHT</code> to reflect the increased time available for block production.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const </span>MAXIMUM_BLOCK_WEIGHT: Weight = Weight::from_parts(
	WEIGHT_REF_TIME_PER_SECOND.saturating_mul(<span class="number">2</span>),
	cumulus_primitives_core::relay_chain::MAX_POV_SIZE <span class="kw">as </span>u64,
);</code></pre></div>
<ol start="5">
<li>Add a feature flagged alternative for <code>MinimumPeriod</code> in <code>pallet_timestamp</code>. The type should
be <code>ConstU64&lt;0&gt;</code> with the feature flag experimental, and <code>ConstU64&lt;{SLOT_DURATION / 2}&gt;</code>
without.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>pallet_timestamp::Config <span class="kw">for </span>Runtime {
    ..
    <span class="attr">#[cfg(feature = <span class="string">"experimental"</span>)]
    </span><span class="kw">type </span>MinimumPeriod = ConstU64&lt;<span class="number">0</span>&gt;;
    <span class="attr">#[cfg(not(feature = <span class="string">"experimental"</span>))]
    </span><span class="kw">type </span>MinimumPeriod = ConstU64&lt;{ SLOT_DURATION / <span class="number">2 </span>}&gt;;
    ..
}</code></pre></div><h3 id="timing-by-block-number"><a class="doc-anchor" href="#timing-by-block-number">§</a>Timing by Block Number</h3>
<p>With asynchronous backing it will be possible for teyrchains to opt for a block time of 6
seconds rather than 12 seconds. But modifying block duration isn’t so simple for a teyrchain
which was measuring time in terms of its own block number. It could result in expected and
actual time not matching up, stalling the teyrchain.</p>
<p>One strategy to deal with this issue is to instead rely on relay chain block numbers for timing.
Relay block number is kept track of by each teyrchain in <code>pallet-teyrchain-system</code> with the
storage value <code>LastRelayChainBlockNumber</code>. This value can be obtained and used wherever timing
based on block number is needed.</p>
</div></details></section></div></main></body></html>